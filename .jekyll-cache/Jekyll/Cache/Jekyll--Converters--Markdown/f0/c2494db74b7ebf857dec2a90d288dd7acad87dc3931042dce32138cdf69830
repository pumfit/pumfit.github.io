I"L2<h1 id="-싱글턴-패턴-singleton"><strong>👀 싱글턴 패턴 (Singleton)</strong></h1>

<p><img src="/assets/img/post/programmingPattern/Singleton.png" alt="img-graphicspipeline" /></p>

<blockquote>
  <p>오직 한개의 클래스 인스터스만을 가지도록 보장하고 이에 대한 전역적인 접근점을 제공한다. GoF 디자인 패턴 81p</p>
</blockquote>

<p>한가지 스포너가 한 가지 몬스터 인스턴스만 만드는 경우 만약 몬스터 클래스마다 스포너 클래스를 만든다고하면 스포너 클래스의 상속구조가 몬스터 클래스의 상속 구조와 동일할 것이다.</p>

<p>이와 같은 문제는 <strong>프로토타입 패턴</strong>으로 해결할 수 있다. 핵심은 어떤 객체가 자기와 비슷한 객체를 스폰할 수 있다는 점이다,</p>

<h2 id="싱글턴-패턴"><strong>🚀싱글턴 패턴</strong></h2>

<ul>
  <li><strong>오직 한  개의 클래스 인스턴스만 가지도록 보장한다.</strong>
    <ul>
      <li>인스턴스가 여러 개면 외부와 상호작용하며 제대로 작동되지 않는 경우가 생길 수 있다.</li>
      <li>Ex) 파일 시스템 API를 래핑하는 클래스
        <ul>
          <li>해당 클래스는 파일작업이 동시에 일어 날 수 있으므로 비동기적으로 동작한다.</li>
          <li>래퍼 클래스가 두 작업을 다 파악해서 서로 간섭하지 못하게 해야한다.</li>
          <li>아무데서나 파일 시스템 클래스 인스턴스를 만들 수 있다면 다른 인스턴스에서 어떤 작업을 진행중인지 알 수 없게 된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>전역 접근점을 제공</strong>
    <ul>
      <li>싱글턴은 그 인스턴스를 <strong>전역에서 접근할 수 있는 메서드를 제공</strong>한다. 이를통해서 누구든지 어디서든지 인스턴스에 접근할 수 있다.</li>
    </ul>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>  <span class="n">Class</span> <span class="n">FileSystem</span><span class="p">{</span>
  	<span class="k">public</span> <span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">(){</span>
  		<span class="c1">// 게으른 초기화 (lazy initialization) 호출시에 인스턴스가 존재하지 않는다면 생성하고 반환한다.</span>
  		<span class="k">if</span><span class="p">(</span><span class="n">instance_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  		<span class="p">{</span>
  			<span class="n">instance_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileSystem</span><span class="p">();</span>
  			<span class="k">return</span> <span class="o">*</span><span class="n">instance_</span><span class="p">;</span>
  		<span class="p">}</span>
  	<span class="p">}</span>
  	<span class="nl">private:</span>
  	<span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>
  	<span class="k">static</span> <span class="n">FileSystem</span><span class="o">*</span> <span class="n">instance_</span><span class="p">;</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <ul>
      <li><strong>lazy initialization</strong> : 객체 생성, 값 계산, 또는 일부 기타 비용이 많이 드는 과정을 처음 필요한 시점까지 지연시키는 기법 즉 인스턴스를 호출하는 순간에 초기화를 해주는 기법이다.</li>
      <li>생성자가 private라 밖에서는 생성불가</li>
      <li>public 의 instance() 정적 메서드는 코드 어디에서나 접근 가능</li>
    </ul>
  </li>
</ul>

<h2 id="-싱글턴을-왜-사용하는가">🤔 <strong>싱글턴을 왜 사용하는가?</strong></h2>

<ul>
  <li><strong>한번도 사용하지 않는 다면 아예 인스턴스를 생성하지 않는다.</strong></li>
</ul>

<p>메모리와 CPU사용량을 줄일 수 있음</p>

<ul>
  <li><strong>런타임에 초기화된다.</strong></li>
</ul>

<p>싱글턴 대신 정적 클래스를 사용할 수도 있지만 정적 맴버 변수는 자동 초기화되는 문제가 있음</p>

<p>정적 변수 초기화 순서도 컴파일러에서 보장해주지 않기 때문에 한 정적 변수가 다른 정적 변수에 안전하게 의존적일 수 없음</p>

<p>순환 의존만 없다면 초기화할때 다른 싱글턴을 참조해도 괜찮다.</p>

<ul>
  <li><strong>싱글턴을 상속할 수 있다.</strong></li>
</ul>

<p>싱글턴의 상속은 잘 사용되지않는 방법이지만 강력하다.</p>

<p>파일 시스쳄 레퍼가 크로스 플랫폼을 지원해아 한다면 추상 인터페이스를 만든뒤 플랫폼마다 구체 클래스를 만들면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="n">Class</span> <span class="n">FileSystem</span><span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span> <span class="o">~</span><span class="n">FileSystem</span><span class="p">(){}</span>
		<span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">protected:</span>
<span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">FileSystem</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#if PLATFROM == PLAYSTATION3
</span>    <span class="k">static</span> <span class="n">FileSystem</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PS3FileSystem</span><span class="p">();</span>
<span class="cp">#elif PLATFORM == WII
</span>    <span class="k">static</span> <span class="n">FileSystem</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WiiFileSystem</span><span class="p">();</span>
<span class="cp">#endif
</span>    <span class="k">return</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>컴파일러가 시스템에 맞는 파일 시스템 객체를 만들 수 있게된다.</p>

<h2 id="싱글턴의-문제점">😥<strong>싱글턴의 문제점</strong></h2>

<p>길게 놓고 보면 비용을 지불하게 됨</p>

<ul>
  <li><strong>알고보니 전역 변수인 경우</strong>
    <ul>
      <li>설계와 유지보수성이 병목</li>
      <li>하드웨어의 한계보다 생산성 한계 때문에</li>
    </ul>
  </li>
</ul>

<p>+) 전역변수의 나쁜점</p>

<ul>
  <li>전역변수는 코드를 이해하기 어렵게 한다.</li>
  <li>전역변수는 커플링을 조장한다.</li>
  <li>전역변수는 멀티스레딩 같은 동시성 프로그래밍에 알맞지 않다.</li>
</ul>

<p>무엇인가를 전역으로 만들면 스레드가 보고 수정할 수 있는 메모리 영역이 생기는 셈이다. 다른 스레드가 전역 데이터에 무슨 작업을 하는지 모르는 때도 있다. 이러다보면 <strong>교착상태, 경쟁 상태</strong>에 빠지게된다.</p>

<h3 id="️-멀티-스레딩-환경에서-싱글톤-사용">🗃️ 멀티 스레딩 환경에서 싱글톤 사용</h3>

<p><a href="https://daddygoms.tistory.com/484">멀티스레드 환경에서의 싱글턴</a></p>

<p>멀티 스레드 환경에서 서로 다른 스레드에서 동시에 참조하는 경우 여러 인스턴스가 생성되며 싱글턴에 위배될 수 있다. 싱글톤 사용 시 문제점을 해결할 방안은 아래와 같다.</p>

<ul>
  <li>
    <p>인스턴스를 이른 초기화를 진행한다.</p>
  </li>
  <li>
    <p>getInstance 메서드를 동기화한다. (synchronized 키워드 사용)</p>
  </li>
  <li>
    <p>DCL 기법을 사용한다. (lock 키워드 사용)</p>

    <ul>
      <li>lock 문은 지정된 개체에 대한 상호 배제 잠금을 획득하여 명령문 블록을 실행한 다음, 잠금을 해제한다.</li>
    </ul>
  </li>
</ul>

<h2 id="-싱글턴은-문제가-하나뿐일-때도-두-가지-문제를-풀려-든다">😟 <strong>싱글턴은 문제가 하나뿐일 때도 두 가지 문제를 풀려 든다.</strong></h2>

<p>📌 <strong>게으른 초기화는 제어할 수 없다.</strong></p>

<p>게임의 경우 시스템을 초기화하는 경우 메모리 할당, 리소스 로딩 등 할 일이 많다 보니 시간이 꽤 걸릴 수 있다. 처음 소리를 재생할 때 게으른 초기화를 한다면 프레임이 떨어지고 게임이 버벅일 수 있다.</p>

<p>마찬가지로 메모리 단편화를 막기 위해 메모리 할당을 세밀히 제어하는 것이 좋다.</p>

<p>📌 <strong>힙 어디에 메모리를 할당할 지 제어할 수 있도록 적절한 초기화 시점을 찾아야한다.</strong></p>

<p>정적 인스턴스를 사용하면 게으른 초기화 문제를 해결할 수 있음 하지만 다형성을 사용할 수는 없다.</p>

<p>클래스는 정적 객체 초기화 시점에 생성되므로 인스터스가 필요 없어도 메모리를 해제할 수 없다.</p>

<h2 id="대안">🧐<strong>대안</strong></h2>

<ol>
  <li><strong>클래스가 꼭 필요한가?</strong></li>
</ol>

<p>가능하다면 도우미 클래스에 있던 작동 코드를 모두 원래 클래스로 옮기자. <strong>객체가 스스로를 챙기게 하는게 바로 OOP</strong>이다.</p>

<ol>
  <li><strong>오직한 개의 클래스 인스턴스만 갖도록 보장하기</strong></li>
</ol>

<p>전역 접근 없이 클래스 인스턴스만 한 개로 보장할 수 있는 방법</p>

<p>static  bool instantiated_;를 선언해서 생성되어 있는 지 판단</p>

<p>이때는 런타임에서 인스턴스 개수를 확인 한다는 점이 단점이다.</p>

<ol>
  <li><strong>인스턴스에 쉽게 접근하기</strong></li>
</ol>

<p>쉬운 접근성은 싱글턴을 선택하는 가장 큰 이유지만 원치 않는 곳에도 노출되는 단점을 가짐</p>

<p>객체에서 접근 가능한 다른 방법</p>

<ol>
  <li>
    <p><strong>넘겨주기</strong></p>

    <p>함수의 인자로 넘겨주자</p>
  </li>
  <li>
    <p><strong>상위 클래스로부터 얻기</strong></p>

    <p>상위 객체에 protected로 접근 가능하게</p>
  </li>
  <li>
    <p><strong>이미 전역인 객체로부터 얻기</strong></p>

    <p>전역 클래스 개수줄이기 → 다만 더 많은 코드가 한 클래스와커플링된다는 단점이 있다.</p>
  </li>
  <li>
    <p><strong>서비스 중개자로부터 얻기</strong></p>

    <p>여러 객체에 대한 전역 접근을 제공하는 클래스를 따로 정의한다. (서비스 중계자 패턴 사용)</p>
  </li>
</ol>

<h3 id="싱글턴에-남은-것">😉<strong>싱글턴에 남은 것</strong></h3>

<p><strong>싱글턴을 대체하는 여러 패턴</strong></p>

<ul>
  <li>하위 클래스 샌드박스 패턴 (12장) - 클래스가 같은 인스턴스들이 공용 상태를 전역으로 만들지 않고도 접근할 수 있는 방법을 제공한다.</li>
  <li>서비스 중개자 패턴 (16장) - 객체를 전역으로 접근할 수 있게 하되, 객체를 훨씬 유연하게 설정할 수 있는 방법을 제공한다.</li>
</ul>

<h2 id="-other--reference">📌 Other &amp; Reference</h2>

<p><a href="https://daddygoms.tistory.com/484">멀티스레드 환경에서의 싱글턴 포스팅</a></p>

<p><a href="https://refactoring.guru/design-patterns">디자인 패턴 다시 보기: 경량 패턴</a></p>

<p><a href="https://refactoring.guru/design-patterns/singleton">refactoring guru</a></p>
:ET
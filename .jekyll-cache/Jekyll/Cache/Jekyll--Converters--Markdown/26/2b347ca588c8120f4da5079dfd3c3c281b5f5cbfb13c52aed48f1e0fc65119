I"'<h1 id="-게임-루프-game-loop"><strong>👀 게임 루프 (Game Loop)</strong></h1>

<p>게임의 진행 시간을 유저 입력,프로세서 속도와 디커플링한다.</p>

<h2 id="️-자투리-시간">⏱️ 자투리 시간</h2>

<p>업데이트는 고정 시간 간격을 하더라도, 렌더링은 그냥 진행된다. 이때 두 업데이트 사이에 렌더링이 되는 경우가 생길 수 있다.</p>

<p><img src="/assets/img/post/programmingPattern/timeline.png" alt="img-lifecycleFlowchart" /></p>

<p>업데이트는 고정간격으로 진행되지만 렌더링은 가능할 때마다 진행된다.</p>

<p>lag 값을 통해 렌더링할때 업데이트 프레임이 시간적으로 얼마나 떨어져 있는지를 정확히 알 수 있다.  즉, lag값은 다음 프레임까지 남은 시간이다.</p>

<p>렌더링을 할 때 아래처럼 인수를 넘겨준다.</p>

<p><img src="/assets/img/post/programmingPattern/timelinelag.png" alt="img-lifecycleFlowchart" /></p>

<p><code class="language-plaintext highlighter-rouge">render(lag/ MS_PER_UPDATE);</code> 이제 렌더링은 정규화를 통해 0~1값이 넘어가므로 프레임레이트를 알 필요가 없어진다.</p>

<h2 id="게임-루프-패턴-사용-시-주의점">⏰게임 루프 패턴 사용 시 주의점</h2>

<h3 id="전력-소모-문제">🔋전력 소모 문제</h3>
<ol>
  <li>
    <p>최대한 빠르게 실행하기</p>

    <p>게임 루프에서 따로 OS의 sleep을 호출하지 않고 시간이 남으면 FPS나 그래픽 품질을 더 높인다.</p>

    <p>하지만 해당 방식은 전력도 최대한으로 사용된다.</p>
  </li>
  <li>
    <p>프레임 레이트 제한하기</p>

    <p>프레임레이트에 상한을 두어 게임 루프에서 프레임 시간 안에 할 일이 끝낫다면 나머지 시간동안은 sleep을 호출한다.</p>

    <p>이 방식은 배터리 소모를 줄일 수 있다.</p>
  </li>
</ol>

<h3 id="게임-플레이속도-제어">👟게임 플레이속도 제어</h3>

<ol>
  <li><strong>동기화 없는 고정 시간 간격 방식</strong>
    <ul>
      <li>게임 속도는 하드웨어와 게임 복잡도에 바로 영향을 받는다. 조그만한 차이가 생겨도 게임속도가 계속 변화하게된다.</li>
    </ul>
  </li>
  <li><strong>동기화하는 고정 시간 간격 방식</strong>
    <ul>
      <li>전력 효율이 높다. 매 틱마다 휴식할 수도 있어 전력을 아낄 수 있다.</li>
      <li>게임이 너무 빨라지지 않지만 게임이 너무 느려질 수 있다. 한 프레임에서 게임 업데이트와 렌더링이 오래 걸리면 게임 실행이 느려진다. 또한 시간을 따라 잡기 위해 렌더링 프레임을 낮추지 않다보니 게임플레이가 느려진다.</li>
    </ul>
  </li>
  <li><strong>가변 시간 간격 방식 (Bad)</strong>
    <ul>
      <li>너무 느리거나 너무 빠른 곳에서도 맞춰서 플레이 할 수 있다. 게임이 현실 시간을 따라가지 못한다면, 따라 잡을 수 있도록 시간 간격을 늘린다.</li>
      <li>게임 플레이를 불안정하고 비 결정적으로 만든다. 물리나 네트워크 구현에 있어 문제가 발생한다.</li>
    </ul>
  </li>
  <li>
    <p><strong>업데이트는 고정 시간 간격으로,렌더링은 가변 시간 간격으로</strong></p>

    <p>해당 방식은 고정 시간 간격으로 업데이트 하되, 실제 시간을 따라 잡아야한다면 렌더링 프레임을 낮춘다.</p>
    <ul>
      <li>너무 느리거나 너무 빨라도 잘 적응한다. 게임을 실시간으로 업데이트할 수만 있다면 뒤쳐질 일은 없다. 최고사양 하드웨어에서는 훨씬 부드럽게 보여줄 수 있다.</li>
      <li>휠씬 복잡하다. 구현이 더 복잡하다는게 주된 단점이다. 시간 간격을 정할때  고사양 유저와 저사양 유저를 모두 고려하여 간격을 정해야한다.</li>
    </ul>
  </li>
</ol>

<h2 id="유니티에서의-게임-루프">🔍유니티에서의 게임 루프</h2>
<p>유니티 엔진에서 제공되는 이벤트 함수들을 <strong>MonoBehaviour</strong> 를 상속받으면 쓸 수 있다. 이 이벤트 함수들을 통해 유니티에서 구현된 게임 루프를 사용할 수 있다.</p>

<details>  <summary>유니티 스크립트 라이프 사이클 플로우 차트</summary>  <div>

    <p><img src="/assets/img/post/programmingPattern/lifecycleFlowchart.svg" alt="img-lifecycleFlowchart" />
<a href="https://docs.unity3d.com/kr/2021.3/Manual/ExecutionOrder.html">이벤트 함수의 실행 순서</a></p>

  </div>  
</details>

<p>이벤트 함수의 실행 순서는 위와 같고 아래는 메뉴얼 중 자주 사용하는 이벤트 함수에 대해 가져와 보았다.</p>

<h3 id="첫-번째-씬-로드">🚩첫 번째 씬 로드</h3>

<p>다음 함수는 씬이 시작할 때 (<strong>씬 내에 있는 오브젝트마다 한 번</strong>) 호출됩니다.</p>

<ul>
  <li>
    <p><strong>Awake:</strong>  이 함수는 <strong>항상 Start 함수 전에 호출되며 프리팹이 인스턴스화 된 직후에 호출</strong>됩니다. 게임 오브젝트가 시작하는 동안 비활성 상태인 경우 Awake 함수는 활성화될 때까지 호출되지 않습니다.</p>
  </li>
  <li>
    <p><strong>OnEnable:</strong>  (오브젝트가 활성화된 경우에만): <strong>오브젝트 활성화 직후 이 함수를 호출합니다.</strong> 레벨이 로드되거나 스크립트 컴포넌트를 포함한 게임 오브젝트가 인스턴스화될 때와 같이 MonoBehaviour를 생성할 때 이렇게 할 수 있습니다.</p>
  </li>
</ul>

<p>씬에 추가된 모든 오브젝트에 대해 Start, Update 등 이전에 호출된  <em>모든</em>  스크립트를 위한 Awake 및 OnEnable 함수가 호출됩니다. <strong>따라서 게임플레이 도중 오브젝트를 인스턴스화될 때는 실행되지 않습니다.</strong></p>

<h3 id="-첫-번째-프레임-업데이트-전에">🚩 첫 번째 프레임 업데이트 전에</h3>

<ul>
  <li><strong>Start:</strong>  스크립트 인스턴스가 활성화된 경우에만 <strong>첫 번째 프레임 업데이트 전에</strong> 호출됩니다.</li>
</ul>

<p>씬 에셋에 포함된 모든 오브젝트에 대해 Update 등 이전에 호출된 모든 스크립트를 위한 Start 함수가 호출됩니다. <strong>따라서 게임플레이 도중 오브젝트를 인스턴스화될 때는 실행되지 않습니다.</strong></p>

<h3 id="-업데이트-순서">🚩 업데이트 순서</h3>

<p><img src="/assets/img/post/programmingPattern/unityUpdate.png" alt="img-lifecycleFlowchart" /></p>

<p>게임 로직, 상호작용, 애니메이션, 카메라 포지션의 트랙을 유지할 때, 사용 가능한 몇몇 다른 이벤트가 존재합니다. 일반적인 패턴은  <strong>Update</strong>  함수에 대부분의 작업을 수행하는 것이지만, 사용할 수 있는 다른 함수도 있습니다.</p>

<ul>
  <li>
    <p><strong>FixedUpdate:</strong>  <strong>FixedUpdate</strong>  는 종종  <strong>Update</strong>  보다 더 자주 호출됩니다. 프레임 속도가 낮은 경우 프레임당 여러 번 호출될 수 있으며 프레임 속도가 높은 경우 프레임 사이에 호출되지 않을 수 있습니다. 모든 물리 계산 및 업데이트는  <strong>FixedUpdate</strong>  후 즉시 발생합니다.  <strong>FixedUpdate</strong>  의 움직임 계산을 적용할 때  <strong>Time.deltaTime</strong>  만큼 값을 곱할 필요가 없습니다.  <strong>FixedUpdate</strong>  가 프레임 속도와 관계없이 신뢰할 수있는 타이머에서 호출되기 때문입니다.</p>
  </li>
  <li>
    <p><strong>Update:</strong>  <strong>Update</strong>  는 프레임당 한 번 호출됩니다. 프레임 업데이트를 위한 주요 작업 함수입니다.</p>
  </li>
  <li>
    <p><strong>LateUpdate:</strong>  <strong>LateUpdate</strong>  는  <strong>Update</strong>  가 끝난 후 프레임당 한 번 호출됩니다.  <strong>Update</strong>  에서 수행된 모든 계산은  <strong>LateUpdate</strong>  가 시작할 때 완료됩니다.  <strong>LateUpdate</strong>  는 일반적으로 다음의 3인칭 카메라에 사용합니다. 캐릭터를 움직이고  <strong>Update</strong>  로 방향을 바꾸게 하는 경우  <strong>LateUpdate</strong>  에서 모든 카메라 움직임과 로테이션 계산을 수행할 수 있습니다. 이렇게 하면 카메라가 포지션을 추적하기 전에 캐릭터가 완전히 움직였는지 확인할 수 있습니다.</p>
  </li>
</ul>

<h3 id="-코루틴">🚩 코루틴</h3>

<blockquote>
  <p><strong>📌 일반적인 코루틴 업데이트는 Update 함수가 반환된 후 실행됩니다.</strong></p>
</blockquote>

<p>코루틴은 주어진 YieldInstruction이 완료될 때까지 실행을 중단(양보)할 수 있는 함수입니다. 코루틴의 다른 사용법은 다음과 같습니다.</p>

<ul>
  <li><strong>yield</strong>  코루틴은 모든 Update 함수가 다음 프레임에 호출된 후 계속됩니다.</li>
  <li><strong>yield WaitForSeconds</strong>  지정한 시간이 지난 후, 모든 Update 함수가 프레임에 호출된 후 계속됩니다.</li>
  <li><strong>yield WaitForFixedUpdate</strong>  모든 FixedUpdate가 모든 스크립트에 호출된 후 계속됩니다. FixedUpdate 전에 코루틴이 양보하면 현재 프레임의 FixedUpdate 이후에 재개합니다.</li>
  <li><strong>yield WWW</strong>  WWW 다운로드가 완료된 후 계속됩니다.</li>
  <li><strong>yield StartCoroutine</strong>  코루틴을 연결하고 MyFunc 코루틴이 먼저 완료되기를 기다립니다.</li>
</ul>

<h2 id="-other--reference">📌 Other &amp; Reference</h2>

<p><a href="https://gameprogrammingpatterns.com/game-loop.html#take-a-little-nap">gameprogrammingpatterns-game-loop</a></p>

<p><strong>더 알아보기</strong></p>

<p><a href="https://docs.unity3d.com/kr/2021.3/Manual/ExecutionOrder.html">이벤트 함수의 실행 순서</a></p>
:ET
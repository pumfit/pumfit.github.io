I"9<h1 id="-이중-버퍼-double-buffer"><strong>👀 이중 버퍼 (Double Buffer)</strong></h1>

<p>이중 버퍼는 여러 순차 작업의 결과를 한번에 보여주기 위해 사용된다.</p>

<h2 id="이중버퍼의-필요성">이중버퍼의 필요성</h2>
<ul>
  <li><strong>티어링(tearing,화면 밀림)현상</strong></li>
</ul>

<p><img src="/assets/img/post/programmingPattern/tearing.jpg" alt="img-graphicspipeline" /></p>

<p>게임이 실행되는 동안 비디오 디스플레이가 프레임버퍼를 반복해서 읽는데 <strong>프레임버퍼에 값이 쓰이는 와중에 비디오 드라이버가 프레임 버퍼 값을 읽어 값을 쓰는 도중 읽게 되면</strong> 화면이 깨지게되는 것이다.</p>

<p><img src="/assets/img/post/programmingPattern/doubleBuffer.png" alt="img-graphicspipeline" /></p>

<p>이때, 이중 버퍼 패턴을 통해 코드에서는 픽셀을 한번에 하나씩 그리되, 비디오 드라이버는 전체 픽셀을 한번에 다 읽을 수 있게 한다.</p>

<p>프레임버퍼를 두개 준비한다. 하나의 프레임버퍼는 보이는 프레임저퍼로 값은 해당 버퍼에서만 읽을 수 있다. 그동안 렌더링 코드는 다른 프레임버퍼에 값을 쓰고 모든 값을 쓴 뒤 <strong>버퍼를 교체</strong>한다.</p>

<h2 id="언제-이중-버퍼를-사용하는가">⏰언제 이중 버퍼를 사용하는가?</h2>

<ul>
  <li>순차적으로 변경해야 하는 상태가 있다.</li>
  <li>이 상태는 값 변경 도중에도 접근 가능해야한다.</li>
  <li>바깥 코드에서는 작업 중인 상태에 접근할 수 없어야 한다.</li>
  <li>싱태에 값을 쓰고 있는 도중에도 대기없이 바로 접근이 가능해야한다.</li>
</ul>

<h2 id="구현시-주의-사항">🧐구현시 주의 사항</h2>
<ol>
  <li>
    <p><strong>교체 연산 자체에 시간이 걸린다.</strong></p>

    <p>값을 모두 입력한 경우 버퍼를 교체하게 되는데 이 교체 연산은 원자적이어야 한다. 즉, 교체가 진행될 때 두 버퍼 모두에 접근 할 수 없어야 한다는 점을 생각해야한다.</p>
  </li>
  <li>
    <p><strong>버퍼가 두 개 필요하다.</strong></p>

    <p>메모리 버퍼가 두 개가 필요하므로 메모리 부족한 상황에서는 이중 버퍼 패턴이 부담이 될 수 있다.</p>
  </li>
</ol>

<h2 id="예제-코드">👩‍💻예제 코드</h2>
<p>아래는 단순 그래픽 시스템 예제이다.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Framebuffer</span> <span class="c1">// 프레임 버퍼 클래스</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Framebuffer</span><span class="p">()</span> <span class="p">{</span> <span class="n">clear</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="c1">// 모든 버퍼를 흰색으로 초기화한다.</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">WIDTH</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">pixels_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">WHITE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="c1">// 특정 픽셀을 검은 색으로 칠한다.</span>
  <span class="p">{</span>
    <span class="n">pixels_</span><span class="p">[(</span><span class="n">WIDTH</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">getPixels</span><span class="p">()</span><span class="c1">//픽셀 배열을 불러온다.</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">pixels_</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>

  <span class="kt">char</span> <span class="n">pixels_</span><span class="p">[</span><span class="n">WIDTH</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">];</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">getPixels()</code> 메서드를 통해 픽셀 데이터를 담고 있는 메모리 배열에 접근하며 비디오 드라이버가 화면을 그리기 위해 버퍼값을 해당 함수를 통해 호출한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Scene</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="c1">// 씬에서 버퍼의 draw함수를 통해 순차적으로 그림을 그려나간다.</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c1">// 이 중간에 비디오 드라이버가 getPixels을 호출하면 문제가 생기게 된다.</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span><span class="o">&amp;</span> <span class="n">getBuffer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">buffer_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Framebuffer</span> <span class="n">buffer_</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>여러번 <code class="language-plaintext highlighter-rouge">draw()</code>를 호출해 그림을 그리는 것을 볼 수 있다. 이때, 드라이버에서는 언제나 <code class="language-plaintext highlighter-rouge">getPixels()</code>을 통해 버퍼에 접근할 수 있다.</p>

<p>아래는 이중 버퍼를 통해 문제를 해결하는 방법이다.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Scene</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Scene</span><span class="p">()</span> <span class="c1">// 버퍼 포인터 값을 초기화한다.</span>
  <span class="o">:</span> <span class="n">current_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffers_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
    <span class="n">next_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffers_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>

    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">swap</span><span class="p">();</span><span class="c1">// 모든 정보를 쓴 뒤 next버퍼를 current버퍼로 교체한다.</span>
  <span class="p">}</span>

<span class="c1">//읽는 버퍼는 current_를 반환한다.</span>
  <span class="n">Framebuffer</span><span class="o">&amp;</span> <span class="n">getBuffer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">current_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">void</span> <span class="n">swap</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// 버퍼 포인터만 교체한다.</span>
    <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">current_</span><span class="p">;</span>
    <span class="n">current_</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span>
    <span class="n">next_</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span>  <span class="n">buffers_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 버퍼를 포인터가 current,next 두가지 버퍼를 가리킨다.</span>
  <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">current_</span><span class="p">;</span> <span class="c1">// 읽기가 가능한 버퍼</span>
  <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span> <span class="c1">// 쓰기가 가능한 버퍼</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>이제 렌더링할 때는 next_ 포인터가 가리키는 다음  버퍼에 쓰고 그리고, 비디오 드라이버는 current_ 포인터로 현재 버퍼에 접근해 픽셀을 읽어온다.</p>

<p>이렇게 이중 버퍼를 사용하면 <code class="language-plaintext highlighter-rouge">getBuffer()</code>가 호출되면 <strong>이전에 그린 화면이 들어있는 current 버퍼</strong>를 얻게 된다.</p>

<h2 id="유니티에서의-이중-버퍼-활용">🔍유니티에서의 이중 버퍼 활용</h2>

<h3 id="커스텀-렌더-텍스처">커스텀 렌더 텍스처</h3>

<p><a href="https://docs.unity3d.com/kr/2019.4/Manual/class-CustomRenderTexture.html"><strong>커스텀 렌더 텍스처 유니티 도큐먼트</strong> </a></p>

<p>커스텀 렌더 텍스처는 셰이더를 사용하여 텍스처에 직접 렌더링할 수 있는 렌더 텍스처의 확장이다.</p>

<p>유니티에서 커스텀렌더텍스처를 사용할 때<code class="language-plaintext highlighter-rouge">CustomRenderTexture.doubleBuffered</code> 값을 설정하여 업데이트 도중에도 접근가능하게 설정할 수 있다.</p>

<table>
  <thead>
    <tr>
      <th>프로퍼티</th>
      <th>기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Double Buffered</strong></td>
      <td>텍스처가 이중 버퍼링됩니다. 각 업데이트는 두 개의 버퍼를 스왑하여 사용자가 셰이더에서 이전 업데이트의 결과를 읽을 수 있도록 합니다.</td>
    </tr>
  </tbody>
</table>

<h2 id="-other--reference">📌 Other &amp; Reference</h2>

<p><a href="https://github.com/munificent/game-programming-patterns/blob/master/code/cpp/double-buffer.h">game-programming-patterns github - double-buffer</a></p>

<p><a href="https://commons.wikimedia.org/wiki/File:Tearing_(simulated).jpg#/media/File:Tearing_(simulated).jpg">Tearing Image</a></p>

<p><a href="https://gameprogrammingpatterns.com/double-buffer.html">doubleBuffer Image</a></p>

<p><strong>👾더 알아보기</strong></p>

<p><a href="https://adnoctum.tistory.com/149">MFC 이중 버퍼 예제 관련 포스팅</a></p>

<p><a href="https://learn.microsoft.com/ko-kr/windows/win32/api/wingdi/nf-wingdi-swapbuffers">OpenGL에서 사용되는 swapbuffers</a></p>
:ET
---
title: 'chapter 9 게임 루프 (2)'
date: 2022-10-10 14:00:06+0900
categories: [GameProgramming,GameProgrammingPattern]
tags: [designPattern,gameLoop]
---
# **👀 게임 루프 (Game Loop)**

게임의 진행 시간을 유저 입력,프로세서 속도와 디커플링한다. 
    
## ⏱️ 자투리 시간

업데이트는 고정 시간 간격을 하더라도, 렌더링은 그냥 진행된다. 이때 두 업데이트 사이에 렌더링이 되는 경우가 생길 수 있다.

![img-lifecycleFlowchart](/assets/img/post/programmingPattern/timeline.png)

업데이트는 고정간격으로 진행되지만 렌더링은 가능할 때마다 진행된다.

lag 값을 통해 렌더링할때 업데이트 프레임이 시간적으로 얼마나 떨어져 있는지를 정확히 알 수 있다.  즉, lag값은 다음 프레임까지 남은 시간이다.

렌더링을 할 때 아래처럼 인수를 넘겨준다.
 `render(lag/ MS_PER)UPDATE);` 이제 렌더링은 정규화를 통해 0~1값이 넘어가므로 프레임레이트를 알 필요가 없어진다.

## ⏰게임 루프 패턴 사용 시 주의점

### 🔋전력 소모 문제
1. 최대한 빠르게 실행하기

	게임 루프에서 따로 OS의 sleep을 호출하지 않고 시간이 남으면 FPS나 그래픽 품질을 더 높인다.

	하지만 해당 방식은 전력도 최대한으로 사용된다.

2. 프레임 레이트 제한하기

	프레임레이트에 상한을 두어 게임 루프에서 프레임 시간 안에 할 일이 끝낫다면 나머지 시간동안은 sleep을 호출한다.
	
	이 방식은 배터리 소모를 줄일 수 있다.

### 👟게임 플레이속도 제어

1. **동기화 없는 고정 시간 간격 방식**
- 게임 속도는 하드웨어와 게임 복잡도에 바로 영향을 받는다. 조그만한 차이가 생겨도 게임속도가 계속 변화하게된다.

2. **동기화하는 고정 시간 간격 방식**
- 전력 효율이 높다. 매 틱마다 휴식할 수도 있어 전력을 아낄 수 있다.
- 게임이 너무 빨라지지 않지만 게임이 너무 느려질 수 있다. 한 프레임에서 게임 업데이트와 렌더링이 오래 걸리면 게임 실행이 느려진다. 또한 시간을 따라 잡기 위해 렌더링 프레임을 낮추지 않다보니 게임플레이가 느려진다.

4. **가변 시간 간격 방식 (Bad)**
	- 너무 느리거나 너무 빠른 곳에서도 맞춰서 플레이 할 수 있다. 게임이 현실 시간을 따라가지 못한다면, 따라 잡을 수 있도록 시간 간격을 늘린다.
	- 게임 플레이를 불안정하고 비 결정적으로 만든다. 물리나 네트워크 구현에 있어 문제가 발생한다.

5. **업데이트는 고정 시간 간격으로,렌더링은 가변 시간 간격으로**

	해당 방식은 고정 시간 간격으로 업데이트 하되, 실제 시간을 따라 잡아야한다면 렌더링 프레임을 낮춘다.
	- 너무 느리거나 너무 빨라도 잘 적응한다. 게임을 실시간으로 업데이트할 수만 있다면 뒤쳐질 일은 없다. 최고사양 하드웨어에서는 훨씬 부드럽게 보여줄 수 있다.
	- 휠씬 복잡하다. 구현이 더 복잡하다는게 주된 단점이다. 시간 간격을 정할때  고사양 유저와 저사양 유저를 모두 고려하여 간격을 정해야한다.
	
## 🔍유니티에서의 게임 루프 
유니티 엔진에서 제공되는 이벤트 함수들을 **MonoBehaviour** 를 상속받으면 쓸 수 있다. 이 이벤트 함수들을 통해 유니티에서 구현된 게임 루프를 사용할 수 있다.

<details>  <summary>유니티 스크립트 라이프 사이클 플로우 차트</summary>  <div markdown="1"> 

![img-lifecycleFlowchart](/assets/img/post/programmingPattern/lifecycleFlowchart.svg)
[이벤트 함수의 실행 순서](https://docs.unity3d.com/kr/2021.3/Manual/ExecutionOrder.html)

</div>  
</details>

이벤트 함수의 실행 순서는 위와 같고 아래는 메뉴얼 중 자주 사용하는 이벤트 함수에 대해 가져와 보았다.

###🚩첫 번째 씬 로드

다음 함수는 씬이 시작할 때 (**씬 내에 있는 오브젝트마다 한 번**) 호출됩니다.

-   **Awake:**  이 함수는 **항상 Start 함수 전에 호출되며 프리팹이 인스턴스화 된 직후에 호출**됩니다. 게임 오브젝트가 시작하는 동안 비활성 상태인 경우 Awake 함수는 활성화될 때까지 호출되지 않습니다.

-   **OnEnable:**  (오브젝트가 활성화된 경우에만): **오브젝트 활성화 직후 이 함수를 호출합니다.** 레벨이 로드되거나 스크립트 컴포넌트를 포함한 게임 오브젝트가 인스턴스화될 때와 같이 MonoBehaviour를 생성할 때 이렇게 할 수 있습니다.

씬에 추가된 모든 오브젝트에 대해 Start, Update 등 이전에 호출된  _모든_  스크립트를 위한 Awake 및 OnEnable 함수가 호출됩니다. **따라서 게임플레이 도중 오브젝트를 인스턴스화될 때는 실행되지 않습니다.**

###🚩 첫 번째 프레임 업데이트 전에

-   **Start:**  스크립트 인스턴스가 활성화된 경우에만 **첫 번째 프레임 업데이트 전에** 호출됩니다.

씬 에셋에 포함된 모든 오브젝트에 대해 Update 등 이전에 호출된 모든 스크립트를 위한 Start 함수가 호출됩니다. **따라서 게임플레이 도중 오브젝트를 인스턴스화될 때는 실행되지 않습니다.**

###🚩 업데이트 순서

![img-lifecycleFlowchart](/assets/img/post/programmingPattern/unityUpdate.png)

게임 로직, 상호작용, 애니메이션, 카메라 포지션의 트랙을 유지할 때, 사용 가능한 몇몇 다른 이벤트가 존재합니다. 일반적인 패턴은  **Update**  함수에 대부분의 작업을 수행하는 것이지만, 사용할 수 있는 다른 함수도 있습니다.

-   **FixedUpdate:**  **FixedUpdate**  는 종종  **Update**  보다 더 자주 호출됩니다. 프레임 속도가 낮은 경우 프레임당 여러 번 호출될 수 있으며 프레임 속도가 높은 경우 프레임 사이에 호출되지 않을 수 있습니다. 모든 물리 계산 및 업데이트는  **FixedUpdate**  후 즉시 발생합니다.  **FixedUpdate**  의 움직임 계산을 적용할 때  **Time.deltaTime**  만큼 값을 곱할 필요가 없습니다.  **FixedUpdate**  가 프레임 속도와 관계없이 신뢰할 수있는 타이머에서 호출되기 때문입니다.
    
-   **Update:**  **Update**  는 프레임당 한 번 호출됩니다. 프레임 업데이트를 위한 주요 작업 함수입니다.
    
-   **LateUpdate:**  **LateUpdate**  는  **Update**  가 끝난 후 프레임당 한 번 호출됩니다.  **Update**  에서 수행된 모든 계산은  **LateUpdate**  가 시작할 때 완료됩니다.  **LateUpdate**  는 일반적으로 다음의 3인칭 카메라에 사용합니다. 캐릭터를 움직이고  **Update**  로 방향을 바꾸게 하는 경우  **LateUpdate**  에서 모든 카메라 움직임과 로테이션 계산을 수행할 수 있습니다. 이렇게 하면 카메라가 포지션을 추적하기 전에 캐릭터가 완전히 움직였는지 확인할 수 있습니다.

###🚩 코루틴

> **📌 일반적인 코루틴 업데이트는 Update 함수가 반환된 후 실행됩니다.** 

코루틴은 주어진 YieldInstruction이 완료될 때까지 실행을 중단(양보)할 수 있는 함수입니다. 코루틴의 다른 사용법은 다음과 같습니다.

-   **yield**  코루틴은 모든 Update 함수가 다음 프레임에 호출된 후 계속됩니다.
-   **yield WaitForSeconds**  지정한 시간이 지난 후, 모든 Update 함수가 프레임에 호출된 후 계속됩니다.
-   **yield WaitForFixedUpdate**  모든 FixedUpdate가 모든 스크립트에 호출된 후 계속됩니다. FixedUpdate 전에 코루틴이 양보하면 현재 프레임의 FixedUpdate 이후에 재개합니다.
-   **yield WWW**  WWW 다운로드가 완료된 후 계속됩니다.
-   **yield StartCoroutine**  코루틴을 연결하고 MyFunc 코루틴이 먼저 완료되기를 기다립니다.



## 📌 Other & Reference

[gameprogrammingpatterns-game-loop](https://gameprogrammingpatterns.com/game-loop.html#take-a-little-nap)

**더 알아보기**

[이벤트 함수의 실행 순서](https://docs.unity3d.com/kr/2021.3/Manual/ExecutionOrder.html)
